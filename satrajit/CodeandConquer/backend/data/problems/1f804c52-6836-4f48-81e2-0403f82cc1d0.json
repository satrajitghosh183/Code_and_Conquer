{
  "id": "1f804c52-6836-4f48-81e2-0403f82cc1d0",
  "title": "Decode the Slanted Ciphertext",
  "slug": "decode-the-slanted-ciphertext",
  "description": "A string `originalText` is encoded using a **slanted transposition cipher** to a string `encodedText` with the help of a matrix having a **fixed number of rows** `rows`.\n\n`originalText` is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of `originalText`. The arrow indicates the order in which the cells are filled. All empty cells are filled with `' '`. The number of columns is chosen such that the rightmost column will **not be empty** after filling in `originalText`.\n\n`encodedText` is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to `encodedText`, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\n\nFor example, if `originalText = \"cipher \"` and `rows = 3`, then we encode it in the following manner:\n\nThe blue arrows depict how `originalText` is placed in the matrix, and the red arrows denote the order in which `encodedText` is formed. In the above example, `encodedText = \"ch ie pr \"`.\n\nGiven the encoded string `encodedText` and number of rows `rows`, return _the original string_ `originalText`.\n\n**Note:** `originalText` **does not** have any trailing spaces `' '`. The test cases are generated such that there is only one possible `originalText`.\n\n**Example 1:**\n\n**Input:** encodedText =  \"ch   ie   pr \", rows = 3\n**Output:**  \"cipher \"\n**Explanation:** This is the same example described in the problem description.\n\n**Example 2:**\n\n**Input:** encodedText =  \"iveo    eed   l te   olc \", rows = 4\n**Output:**  \"i love leetcode \"\n**Explanation:** The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.\n\n**Example 3:**\n\n**Input:** encodedText =  \"coding \", rows = 1\n**Output:**  \"coding \"\n**Explanation:** Since there is only 1 row, both originalText and encodedText are the same.\n\n**Constraints:**\n\n*   `0 <= encodedText.length <= 106`\n*   `encodedText` consists of lowercase English letters and `' '` only.\n*   `encodedText` is a valid encoding of some `originalText` that **does not** have trailing spaces.\n*   `1 <= rows <= 1000`\n*   The testcases are generated such that there is **only one** possible `originalText`.",
  "difficulty": "Medium",
  "category": null,
  "xpReward": 0,
  "timeLimitMs": 5000,
  "memoryLimitMb": 256,
  "starterCode": [],
  "solutionCode": "",
  "hints": [],
  "isPremium": false,
  "createdBy": null,
  "testCases": [
    {
      "input": [
        "ch   ie   pr ",
        3
      ],
      "expectedOutput": "cipher "
    },
    {
      "input": [
        "iveo    eed   l te   olc ",
        4
      ],
      "expectedOutput": "i love leetcode "
    },
    {
      "input": [
        "coding ",
        1
      ],
      "expectedOutput": "coding "
    }
  ],
  "hiddenTestCases": [
    {
      "input": [
        "ch   ie   pr ",
        3
      ],
      "expectedOutput": "cipher "
    },
    {
      "input": [
        "iveo    eed   l te   olc ",
        4
      ],
      "expectedOutput": "i love leetcode "
    }
  ],
  "tags": [],
  "constraints": [],
  "examples": [],
  "createdAt": "2025-11-14T21:24:17.110263+00:00",
  "updatedAt": "2025-12-04T04:36:17.791Z"
}
