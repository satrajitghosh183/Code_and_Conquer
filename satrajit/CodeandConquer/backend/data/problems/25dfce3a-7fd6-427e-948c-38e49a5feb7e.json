{
  "id": "25dfce3a-7fd6-427e-948c-38e49a5feb7e",
  "title": "Operations on Tree",
  "slug": "operations-on-tree",
  "description": "You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of the `ith` node. The root of the tree is node `0`, so `parent[0] = -1` since it has no parent. You want to design a data structure that allows users to lock, unlock, and upgrade nodes in the tree.\n\nThe data structure should support the following functions:\n\n*   **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.\n*   **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.\n*   **Upgrade****: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true:\n    *   The node is unlocked,\n    *   It has at least one locked descendant (by **any** user), and\n    *   It does not have any locked ancestors.\n\nImplement the `LockingTree` class:\n\n*   `LockingTree(int[] parent)` initializes the data structure with the parent array.\n*   `lock(int num, int user)` returns `true` if it is possible for the user with id `user` to lock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **locked** by the user with id `user`.\n*   `unlock(int num, int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **unlocked**.\n*   `upgrade(int num, int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num`, or `false` otherwise. If it is possible, the node `num` will be **upgraded**.\n\n**Example 1:**\n\n**Input**\n\\[ \"LockingTree \",  \"lock \",  \"unlock \",  \"unlock \",  \"lock \",  \"upgrade \",  \"lock \"\\]\n\\[\\[\\[-1, 0, 0, 1, 1, 2, 2\\]\\], \\[2, 2\\], \\[2, 3\\], \\[2, 2\\], \\[4, 5\\], \\[0, 1\\], \\[0, 1\\]\\]\n**Output**\n\\[null, true, false, true, true, true, false\\]\n\n**Explanation**\nLockingTree lockingTree = new LockingTree(\\[-1, 0, 0, 1, 1, 2, 2\\]);\nlockingTree.lock(2, 2);    // return true because node 2 is unlocked.\n                           // Node 2 will now be locked by user 2.\nlockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.\nlockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.\n                           // Node 2 will now be unlocked.\nlockingTree.lock(4, 5);    // return true because node 4 is unlocked.\n                           // Node 4 will now be locked by user 5.\nlockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                           // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\nlockingTree.lock(0, 1);    // return false because node 0 is already locked.\n\n**Constraints:**\n\n*   `n == parent.length`\n*   `2 <= n <= 2000`\n*   `0 <= parent[i] <= n - 1` for `i != 0`\n*   `parent[0] == -1`\n*   `0 <= num <= n - 1`\n*   `1 <= user <= 104`\n*   `parent` represents a valid tree.\n*   At most `2000` calls **in total** will be made to `lock`, `unlock`, and `upgrade`.",
  "difficulty": "Medium",
  "category": null,
  "xpReward": 0,
  "timeLimitMs": 5000,
  "memoryLimitMb": 256,
  "starterCode": [],
  "solutionCode": "",
  "hints": [],
  "isPremium": false,
  "createdBy": null,
  "testCases": [],
  "hiddenTestCases": [],
  "tags": [],
  "constraints": [],
  "examples": [],
  "createdAt": "2025-11-14T21:23:55.020678+00:00",
  "updatedAt": "2025-12-04T04:31:30.042Z"
}
