{
  "id": "8977acfd-a045-4988-ad8c-9d7cb0de8a8d",
  "title": "Binary Search Tree Iterator II",
  "slug": "binary-search-tree-iterator-ii",
  "description": "Implement the `BSTIterator` class that represents an iterator over the **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** of a binary search tree (BST):\n\n*   `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n*   `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.\n*   `int next()` Moves the pointer to the right, then returns the number at the pointer.\n*   `boolean hasPrev()` Returns `true` if there exists a number in the traversal to the left of the pointer, otherwise returns `false`.\n*   `int prev()` Moves the pointer to the left, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.\n\nYou may assume that `next()` and `prev()` calls will always be valid. That is, there will be at least a next/previous number in the in-order traversal when `next()`/`prev()` is called.\n\n**Example 1:**\n\n**Input**\n\\[ \"BSTIterator \",  \"next \",  \"next \",  \"prev \",  \"next \",  \"hasNext \",  \"next \",  \"next \",  \"next \",  \"hasNext \",  \"hasPrev \",  \"prev \",  \"prev \"\\]\n\\[\\[\\[7, 3, 15, null, null, 9, 20\\]\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\], \\[null\\]\\]\n**Output**\n\\[null, 3, 7, 3, 7, true, 9, 15, 20, false, true, 15, 9\\]\n\n**Explanation**\n// The underlined element is where the pointer currently is.\nBSTIterator bSTIterator = new BSTIterator(\\[7, 3, 15, null, null, 9, 20\\]); // state is  \\[3, 7, 9, 15, 20\\]\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 3\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 7\nbSTIterator.prev(); // state becomes \\[3, 7, 9, 15, 20\\], return 3\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 7\nbSTIterator.hasNext(); // return true\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 9\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 15\nbSTIterator.next(); // state becomes \\[3, 7, 9, 15, 20\\], return 20\nbSTIterator.hasNext(); // return false\nbSTIterator.hasPrev(); // return true\nbSTIterator.prev(); // state becomes \\[3, 7, 9, 15, 20\\], return 15\nbSTIterator.prev(); // state becomes \\[3, 7, 9, 15, 20\\], return 9\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 105]`.\n*   `0 <= Node.val <= 106`\n*   At most `105` calls will be made to `hasNext`, `next`, `hasPrev`, and `prev`.\n\n**Follow up:** Could you solve the problem without precalculating the values of the tree?",
  "difficulty": "Medium",
  "category": null,
  "xpReward": 0,
  "timeLimitMs": 5000,
  "memoryLimitMb": 256,
  "starterCode": [],
  "solutionCode": "",
  "hints": [],
  "isPremium": false,
  "createdBy": null,
  "testCases": [],
  "hiddenTestCases": [],
  "tags": [],
  "constraints": [],
  "examples": [],
  "createdAt": "2025-11-14T21:22:19.817625+00:00",
  "updatedAt": "2025-12-04T04:31:30.768Z"
}
