{
  "exportedAt": "2025-12-04T03:28:44.179Z",
  "totalProblems": 10,
  "problems": [
    {
      "id": "449f87d1-3d41-4406-bee2-19993beaf36a",
      "title": "Minimum Reverse Operations",
      "difficulty": "Hard",
      "description": "You are given an integer `n` and an integer `p` in the range `[0, n - 1]`. Representing a **0-indexed** array `arr` of length `n` where all positions are set to `0`'s, except position `p` which is set to `1`.\n\nYou are also given an integer array `banned` containing some positions from the array. For the **i****th** position in `banned`, `arr[banned[i]] = 0`, and `banned[i] != p`.\n\nYou can perform **multiple** operations on `arr`. In an operation, you can choose a **subarray** with size `k` and **reverse** the subarray. However, the `1` in `arr` should never go to any of the positions in `banned`. In other words, after each operation `arr[banned[i]]` **remains** `0`.\n\n_Return an array_ `ans` _where_ _for each_ `i` _from_ `[0, n - 1]`, `ans[i]` _is the **minimum** number of reverse operations needed to bring the_ `1` _to position_ `i` _in arr_, _or_ `-1` _if it is impossible_.\n\n*   A **subarray** is a contiguous **non-empty** sequence of elements within an array.\n*   The values of `ans[i]` are independent for all `i`'s.\n*   The **reverse** of an array is an array containing the values in **reverse order**.\n\n**Example 1:**\n\n**Input:** n = 4, p = 0, banned = \\[1,2\\], k = 4\n**Output:** \\[0,-1,-1,1\\]\n**Explanation:** In this case `k = 4` so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is `0`. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is `-1`. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is `1`. \n\n**Example 2:**\n\n**Input:** n = 5, p = 0, banned = \\[2,4\\], k = 3\n**Output:** \\[0,-1,-1,-1,-1\\]\n**Explanation:** In this case the 1 is initially at position 0, so the answer for that position is `0`. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray `[0, 2]` for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions `-1`. \n\n**Example 3:**\n\n**Input:** n = 4, p = 2, banned = \\[0,1,3\\], k = 1\n**Output:** \\[-1,-1,0,-1\\]\n**Explanation:** In this case we can only perform reverse operations of size 1. So the 1 never changes its position.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `0 <= p <= n - 1`\n*   `0 <= banned.length <= n - 1`\n*   `0 <= banned[i] <= n - 1`\n*   `1 <= k <= n`\n*   `banned[i] != p`\n*   all values in `banned` are **unique**",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "55f50dd2-a86a-44ff-95b8-a5f2c7e13389",
      "title": "Mice and Cheese",
      "difficulty": "Medium",
      "description": "There are two mice and `n` different types of cheese, each type of cheese should be eaten by exactly one mouse.\n\nA point of the cheese with index `i` (**0-indexed**) is:\n\n*   `reward1[i]` if the first mouse eats it.\n*   `reward2[i]` if the second mouse eats it.\n\nYou are given a positive integer array `reward1`, a positive integer array `reward2`, and a non-negative integer `k`.\n\nReturn _**the maximum** points the mice can achieve if the first mouse eats exactly_ `k` _types of cheese._\n\n**Example 1:**\n\n**Input:** reward1 = \\[1,1,3,4\\], reward2 = \\[4,4,1,1\\], k = 2\n**Output:** 15\n**Explanation:** In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\n**Example 2:**\n\n**Input:** reward1 = \\[1,1\\], reward2 = \\[1,1\\], k = 2\n**Output:** 2\n**Explanation:** In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n**Constraints:**\n\n*   `1 <= n == reward1.length == reward2.length <= 105`\n*   `1 <= reward1[i], reward2[i] <= 1000`\n*   `0 <= k <= n`",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "7362acd5-f31b-40cc-b391-d8334e3ec756",
      "title": "Convert an Array Into a 2D Array With Conditions",
      "difficulty": "Medium",
      "description": "You are given an integer array `nums`. You need to create a 2D array from `nums` satisfying the following conditions:\n\n*   The 2D array should contain **only** the elements of the array `nums`.\n*   Each row in the 2D array contains **distinct** integers.\n*   The number of rows in the 2D array should be **minimal**.\n\nReturn _the resulting array_. If there are multiple answers, return any of them.\n\n**Note** that the 2D array can have a different number of elements on each row.\n\n**Example 1:**\n\n**Input:** nums = \\[1,3,4,1,2,3,1\\]\n**Output:** \\[\\[1,3,4,2\\],\\[1,3\\],\\[1\\]\\]\n**Explanation:** We can create a 2D array that contains the following rows:\n- 1,3,4,2\n- 1,3\n- 1\nAll elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.\nIt can be shown that we cannot have less than 3 rows in a valid array.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** \\[\\[4,3,2,1\\]\\]\n**Explanation:** All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= nums.length`",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "4309ffd5-420d-431e-8128-8333ae50a82f",
      "title": "Find the Longest Balanced Substring of a Binary String",
      "difficulty": "Easy",
      "description": "You are given a binary string `s` consisting only of zeroes and ones.\n\nA substring of `s` is considered balanced if **all zeroes are before ones** and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.\n\nReturn _the length of the longest balanced substring of_ `s`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n**Input:** s =  \"01000111 \"\n**Output:** 6\n**Explanation:** The longest balanced substring is  \"000111 \", which has length 6.\n\n**Example 2:**\n\n**Input:** s =  \"00111 \"\n**Output:** 4\n**Explanation:** The longest balanced substring is  \"0011 \", which has length 4. \n\n**Example 3:**\n\n**Input:** s =  \"111 \"\n**Output:** 0\n**Explanation:** There is no balanced substring except the empty substring, so the answer is 0.\n\n**Constraints:**\n\n*   `1 <= s.length <= 50`\n*   `'0' <= s[i] <= '1'`",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "b5540d8b-db4b-47e7-9310-c0bdd4c4c473",
      "title": "Shortest Cycle in a Graph",
      "difficulty": "Hard",
      "description": "There is a **bi-directional** graph with `n` vertices, where each vertex is labeled from `0` to `n - 1`. The edges in the graph are represented by a given 2D integer array `edges`, where `edges[i] = [ui, vi]` denotes an edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\n\nReturn _the length of the **shortest** cycle in the graph_. If no cycle exists, return `-1`.\n\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.\n\n**Example 1:**\n\n**Input:** n = 7, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,0\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[6,3\\]\\]\n**Output:** 3\n**Explanation:** The cycle with the smallest length is : 0 -> 1 -> 2 -> 0 \n\n**Example 2:**\n\n**Input:** n = 4, edges = \\[\\[0,1\\],\\[0,2\\]\\]\n**Output:** -1\n**Explanation:** There are no cycles in this graph.\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= edges.length <= 1000`\n*   `edges[i].length == 2`\n*   `0 <= ui, vi < n`\n*   `ui != vi`\n*   There are no repeated edges.",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "ab5c9561-2db1-45a0-a688-2f543c930abe",
      "title": "Make K-Subarray Sums Equal",
      "difficulty": "Medium",
      "description": "You are given a **0-indexed** integer array `arr` and an integer `k`. The array `arr` is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.\n\nYou can do the following operation any number of times:\n\n*   Pick any element from `arr` and increase or decrease it by `1`.\n\nReturn _the minimum number of operations such that the sum of each **subarray** of length_ `k` _is equal_.\n\nA **subarray** is a contiguous part of the array.\n\n**Example 1:**\n\n**Input:** arr = \\[1,4,1,3\\], k = 2\n**Output:** 1\n**Explanation:** we can do one operation on index 1 to make its value equal to 3.\nThe array after the operation is \\[1,3,1,3\\]\n- Subarray starts at index 0 is \\[1, 3\\], and its sum is 4 \n- Subarray starts at index 1 is \\[3, 1\\], and its sum is 4 \n- Subarray starts at index 2 is \\[1, 3\\], and its sum is 4 \n- Subarray starts at index 3 is \\[3, 1\\], and its sum is 4 \n\n**Example 2:**\n\n**Input:** arr = \\[2,5,5,7\\], k = 3\n**Output:** 5\n**Explanation:** we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.\nThe array after the operations is \\[5,5,5,5\\]\n- Subarray starts at index 0 is \\[5, 5, 5\\], and its sum is 15\n- Subarray starts at index 1 is \\[5, 5, 5\\], and its sum is 15\n- Subarray starts at index 2 is \\[5, 5, 5\\], and its sum is 15\n- Subarray starts at index 3 is \\[5, 5, 5\\], and its sum is 15 \n\n**Constraints:**\n\n*   `1 <= k <= arr.length <= 105`\n*   `1 <= arr[i] <= 109`",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "0ebd98aa-94d6-486f-bd07-10b4c6271ae1",
      "title": "Find the Substring With Maximum Cost",
      "difficulty": "Medium",
      "description": "You are given a string `s`, a string `chars` of **distinct** characters and an integer array `vals` of the same length as `chars`.\n\nThe **cost of the substring** is the sum of the values of each character in the substring. The cost of an empty string is considered `0`.\n\nThe **value of the character** is defined in the following way:\n\n*   If the character is not in the string `chars`, then its value is its corresponding position **(1-indexed)** in the alphabet.\n    *   For example, the value of `'a'` is `1`, the value of `'b'` is `2`, and so on. The value of `'z'` is `26`.\n*   Otherwise, assuming `i` is the index where the character occurs in the string `chars`, then its value is `vals[i]`.\n\nReturn _the maximum cost among all substrings of the string_ `s`.\n\n**Example 1:**\n\n**Input:** s =  \"adaa \", chars =  \"d \", vals = \\[-1000\\]\n**Output:** 2\n**Explanation:** The value of the characters  \"a \" and  \"d \" is 1 and -1000 respectively.\nThe substring with the maximum cost is  \"aa \" and its cost is 1 + 1 = 2.\nIt can be proven that 2 is the maximum cost.\n\n**Example 2:**\n\n**Input:** s =  \"abc \", chars =  \"abc \", vals = \\[-1,-1,-1\\]\n**Output:** 0\n**Explanation:** The value of the characters  \"a \",  \"b \" and  \"c \" is -1, -1, and -1 respectively.\nThe substring with the maximum cost is the empty substring  \" \" and its cost is 0.\nIt can be proven that 0 is the maximum cost.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consist of lowercase English letters.\n*   `1 <= chars.length <= 26`\n*   `chars` consist of **distinct** lowercase English letters.\n*   `vals.length == chars.length`\n*   `-1000 <= vals[i] <= 1000`",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "1777e866-d9c7-4721-9a84-f1c7f3850876",
      "title": "Form Smallest Number From Two Digit Arrays",
      "difficulty": "Easy",
      "description": "Given two arrays of **unique** digits `nums1` and `nums2`, return _the **smallest** number that contains **at least** one digit from each array_.\n\n**Example 1:**\n\n**Input:** nums1 = \\[4,1,3\\], nums2 = \\[5,7\\]\n**Output:** 15\n**Explanation:** The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.\n\n**Example 2:**\n\n**Input:** nums1 = \\[3,5,2,6\\], nums2 = \\[3,1,7\\]\n**Output:** 3\n**Explanation:** The number 3 contains the digit 3 which exists in both arrays.\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 9`\n*   `1 <= nums1[i], nums2[i] <= 9`\n*   All digits in each array are **unique**.",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "597417eb-c9cd-4817-a711-d802e6658af0",
      "title": "Minimum Time to Eat All Grains",
      "difficulty": "Hard",
      "description": "There are `n` hens and `m` grains on a line. You are given the initial positions of the hens and the grains in two integer arrays `hens` and `grains` of size `n` and `m` respectively.\n\nAny hen can eat a grain if they are on the same position. The time taken for this is negligible. One hen can also eat multiple grains.\n\nIn `1` second, a hen can move right or left by `1` unit. The hens can move simultaneously and independently of each other.\n\nReturn _the **minimum** time to eat all grains if the hens act optimally._\n\n**Example 1:**\n\n**Input:** hens = \\[3,6,7\\], grains = \\[2,4,7,9\\]\n**Output:** 2\n**Explanation:** \nOne of the ways hens eat all grains in 2 seconds is described below:\n- The first hen eats the grain at position 2 in 1 second. \n- The second hen eats the grain at position 4 in 2 seconds. \n- The third hen eats the grains at positions 7 and 9 in 2 seconds. \nSo, the maximum time needed is 2.\nIt can be proven that the hens cannot eat all grains before 2 seconds.\n\n**Example 2:**\n\n**Input:** hens = \\[4,6,109,111,213,215\\], grains = \\[5,110,214\\]\n**Output:** 1\n**Explanation:** \nOne of the ways hens eat all grains in 1 second is described below:\n- The first hen eats the grain at position 5 in 1 second. \n- The fourth hen eats the grain at position 110 in 1 second.\n- The sixth hen eats the grain at position 214 in 1 second. \n- The other hens do not move. \nSo, the maximum time needed is 1.\n\n**Constraints:**\n\n*   `1 <= hens.length, grains.length <= 2*104`\n*   `0 <= hens[i], grains[j] <= 109`",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    },
    {
      "id": "52a0544a-90e7-4810-a9d6-cd2e98e53904",
      "title": "Collect Coins in a Tree",
      "difficulty": "Hard",
      "description": "There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.",
      "examples": [],
      "constraints": [],
      "starterCode": {},
      "tags": []
    }
  ]
}
